{{ $data := . -}}

// Copyright © 2019 - 2020 Oscar Campos <oscar.campos@thepimpam.com>
// Copyright © 2017 - William Edwards
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ==================================================================
// This file was autogenerated by PimPam GDNative-Go binding tools
// Please do not modify this file, any change will be lost
// ==================================================================

{{/* create wrapper boilerplate */}}
package {{ $data.Package }}

import (
    "fmt"

    "gitlab.com/pimpam-games-studio/gdnative-go/gdnative"
)

{{ range $className, $class := $data.Classes -}}
// {{ $className }}Wrapper is a wrapper over {{ $className }} that will register it with in godot
type {{ $className }}Wrapper struct {
    class *{{ $className }}
}

// {{ $className }}Instances is an internal registry of instances for our custom types
var {{ $className }}Instances = map[string]*{{ $className }}Wrapper{}

// handle{{ $className }} handles calls from Godot to this instance methods
func handle{{ $className }}(object gdnative.Object, methodData, userData string, numArgs int, args []gdnative.Variant) gdnative.Variant {

    // lookup instance on registry, if it does not exists return nil
	instance, ok := {{ $className }}Instances[userData]
	if !ok {
        gdnative.Log.Warning(fmt.Sprintf("could not find instance %s on registry", userData))
		return gdnative.NewVariantNil()
	}

    // find the right method and execute it or return an empty nil value and log it
    switch methodData {
        {{ range $i, $method := $class.Methods -}}
        case "{{ $method.GodotName }}":
            {{ range $i, $arg := $method.Arguments -}}
            {{ $arg.Name }} := args[{{ $i }}].{{ $arg.ConvertFunction }}
            {{ end -}}

            {{ if $method.HasReturns -}}
            value := instance.class.{{ $method.FunctionCallWithParams }}
            return {{ $method.NewVariantType }}
            {{ else -}}
            instance.class.{{ $method.FunctionCallWithParams }}
            return gdnative.NewVariantNil()
            {{ end -}}
        {{ end -}}
    }

    // if we are here it means the method being called is unknown to us
    gdnative.Log.Warning(fmt.Sprintf("could not find method %s on instance %s", methodData, userData))
    return gdnative.NewVariantNil()
}

// nativeScriptInit{{ $className }} will run upon NativeScript initialization and its
// responsible for registering all our classes within Godot
func nativeScriptInit{{ $className }}() {

    // define an instance creation function, it will be called by Godot
    constructor := gdnative.CreateConstructor("{{ $className }}", func(object gdnative.Object, methodData string) string {
        // create a new value of this wrapper type
        {{ if $class.HasConstructor -}}
        instance := {{ $className }}Wrapper{
            class: {{ $class.Constructor }}(),
        }
        {{ else -}}
        instance := {{ $className }}Wrapper{
            class: ${{ $className }}{},
        }
        {{ end -}}

        // use the pointer address as instance ID
        instanceID := fmt.Sprintf("{{ $className }}Wrapper_%p", &instance)
        {{ $className }}Instances[instanceID] = &instance

        // return the instance ID to Godot
        return instanceID
    })

    // define an instance destruction function, it will be called by Godot
    destructor := gdnative.CreateDestructor("{{ $className }}", func(object gdnative.Object, methodData, userData string) {
        {{ if $class.HasDestructor -}}
        {{ $class.Destructor }}()
        {{ end -}}
        delete({{ $className }}Instances, userData)
    })

    // define methods attached to the instance
    methods := []gdnative.Method{
        {{ range $methodName, $method := $class.Methods -}}
        gdnative.NewGodotMethod("{{ $className }}", "{{ $method.GodotName }}", handle{{ $className }}),
        {{ end -}}
    }

    // define properties attached to the instance
    properties := []gdnative.Property{
        {{ range $propertyName, $property := $class.GetProperties -}}
        gdnative.NewGodotProperty("{{ $className }}", {{ $property.Name }}, $property.Hint, $property.HintString, $property.Usage, $property.RsetType, $property.SetFunc, $property.GetFunc),
        {{ end -}}
    }

    // register a new class within Godot
	gdnative.RegisterNewGodotClass(false, "{{ $className }}", "{{ $class.GetBase }}", &constructor, &destructor, methods, properties)
}
{{ end -}}{{/* range $className, $class := $data.Classes */ -}}

// The "init()" function is a special Go function that will be called when this library
// is initialized. Here we can register our Godot classes.
func init() {

    {{ $data.GDNativeInit }}
}
