// Copyright © 2019 - 2020 Oscar Campos <oscar.campos@thepimpam.com>
// Copyright © 2017 - William Edwards
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

// ==================================================================
// This file was autogenerated by PimPam GDNative-Go binding tools
// Please do not modify this file, any change will be lost
// ==================================================================

import (
	"fmt"
	"reflect"

	"gitlab.com/pimpam-games-studio/gdnative-go/gdnative"
)

// SimpleClassWrapper is a wrapper over SimpleClass that will register it with in godot
type SimpleClassWrapper struct {
	class *SimpleClass
}

// LookupInstance implements the gdnative.InstanceRegistry interface for SimpleClassWrapper
func (w *SimpleClassWrapper) LookupInstance(instance string) *SimpleClassWrapper {

	wrapper, ok := SimpleClassInstances[instance]
	if !ok {
		return nil
	}

	return wrapper
}

// SimpleClassInstances is an internal registry of instances for our custom types
var SimpleClassInstances = map[string]*SimpleClassWrapper{}

// handleSimpleClass handles calls from Godot to this instance methods
func handleSimpleClass(object gdnative.Object, methodData, userData string, numArgs int, args []gdnative.Variant) gdnative.Variant {

	// lookup instance on registry, if it does not exists return nil
	instance, ok := SimpleClassInstances[userData]
	if !ok {
		gdnative.Log.Warning(fmt.Sprintf("could not find instance %s on registry", userData))
		return gdnative.NewVariantNil()
	}

	// find the right method and execute it or return an empty nil value and log it
	switch methodData {
	case "get_data":
		value := instance.class.GetData()
		return value
	}

	// if we are here it means the method being called is unknown to us
	gdnative.Log.Warning(fmt.Sprintf("could not find method %s on instance %s", methodData, userData))
	return gdnative.NewVariantNil()
}

// nativeScriptInitSimpleClass will run upon NativeScript initialization and its
// responsible for registering all our classes within Godot
func nativeScriptInitSimpleClass() {

	// define an instance creation function, it will be called by Godot
	constructor := gdnative.CreateConstructor("SIMPLE", func(object gdnative.Object, methodData string) string {
		// create a new value of this wrapper type
		instance := SimpleClassWrapper{
			class: New(),
		}
		// use the pointer address as instance ID
		instanceID := fmt.Sprintf("SimpleClassWrapper_%p", &instance)
		SimpleClassInstances[instanceID] = &instance

		// return the instance ID to Godot
		return instanceID
	})

	// define an instance destruction function, it will be called by Godot
	destructor := gdnative.CreateDestructor("SIMPLE", func(object gdnative.Object, methodData, userData string) {
		delete(SimpleClassInstances, userData)
	})

	// define methods attached to the instance
	methods := []gdnative.Method{
		gdnative.NewGodotMethod("SIMPLE", "get_data", handleSimpleClass),
	}

	// define properties attached to the instance
	properties := []gdnative.Property{
		gdnative.NewGodotProperty("SIMPLE", "HP", "gdnative.PropertyHintRange", "The player's Hit Points", "gdnative.PropertyUsageDefault", "gdnative.MethodRpcModeDisabled", nil, nil),
		gdnative.NewGodotProperty("SIMPLE", "Mana", "gdnative.PropertyHintRange", "The player points to cast spells", "gdnative.PropertyUsageDefault", "gdnative.MethodRpcModeDisabled", nil, nil),
		gdnative.NewGodotProperty("SIMPLE", "Blood", "gdnative.PropertyHintRange", "The player points to cast spells", "gdnative.PropertyUsageDefault", "gdnative.MethodRpcModeDisabled", nil, nil),
	}

	for i := range properties {
		var setter gdnative.InstancePropertySet
		setter.SetFunc = func(object gdnative.Object, classProperty, instanceString string, property gdnative.Variant) {

			class, ok := SimpleClassInstances[instanceString]
			if !ok {
				panic(fmt.Sprintf("Set property %s does not exists on instance %s registry", classProperty, instanceString))
			}

			propertyField := reflect.ValueOf(reflect.ValueOf(class)).Elem().FieldByName(properties[i].GetName())
			propertyField.Set(reflect.ValueOf(property))
		}
		setter.FreeFunc = func(methodData string) {}

		var getter gdnative.InstancePropertyGet
		getter.GetFunc = func(object gdnative.Object, classProperty, instanceString string) gdnative.Variant {

			class, ok := SimpleClassInstances[instanceString]
			if !ok {
				panic(fmt.Sprintf("Set property %s does not exists on instance %s registry", classProperty, instanceString))
			}

			propertyField := reflect.ValueOf(reflect.ValueOf(class)).Elem().FieldByName(properties[i].GetName())
			return gdnative.GoTypeToVariant(propertyField)
		}
		getter.FreeFunc = func(methodData string) {}
		setter.MethodData = fmt.Sprintf("SIMPLE::%s", properties[i].GetName())
		getter.MethodData = fmt.Sprintf("SIMPLE::%s", properties[i].GetName())
		properties[i].SetSetter(&setter)
		properties[i].SetGetter(&getter)
	}

	// signals attached to the instance
	signals := []gdnative.GDSignal{
		gdnative.NewGodotSignal(
			"SIMPLE",
			"hit",
			[]gdnative.SignalArgument{
				{
					Name:         "power",
					Type:         gdnative.Int(gdnative.VariantTypeInt),
					Hint:         gdnative.PropertyHintRange,
					HintString:   "Hit power value",
					Usage:        gdnative.PropertyUsageDefault,
					DefaultValue: gdnative.NewVariantInt(gdnative.Int64T(0)),
				},
			},
			[]gdnative.Variant{
				gdnative.NewVariantInt(gdnative.Int64T(0)),
			},
		),
	}

	// register a new class within Godot
	gdnative.RegisterNewGodotClass(false, "SIMPLE", "Reference", &constructor, &destructor, methods, properties, signals)
}

// The "init()" function is a special Go function that will be called when this library
// is initialized. Here we can register our Godot classes.
func init() {

	gdnative.SetNativeScriptInit(nativeScriptInitSimpleClass)
}
